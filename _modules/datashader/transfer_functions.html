<!DOCTYPE html>

<html lang="en">
<head>
<!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
<meta charset="utf-8"/>
<title>datashader.transfer_functions — Datashader 0.13.0a0 documentation</title>
<meta content="Turns even the largest data into images, accurately." name="description"/>
<meta content="Datashader contributors" name="author"/>
<!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<!-- FONT
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
<script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.16/webfont.js"></script>
<script>
    WebFont.load({
      google: {
        families: ['Source Sans Pro']
      }
    });
  </script>
<!-- CSS
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
<link href="../../_static/css/main.css" rel="stylesheet"/>
<link href="../../_static/nbsite.css" rel="stylesheet"/>
<!-- Scripts
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript">
</script>
<script src="../../_static/js/main.js"></script>
<script src="../../_static/nbsite.js"></script>
<script src="../../_static/require.js"></script>
<!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
<link href="../../_static/favicon.ico" rel="icon" type="image/png"/>
<!-- Canonical
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
<link href="/_modules/datashader/transfer_functions.html" rel="canonical">
</link></head>
<body class="">
<header class="navigation">
<div class="wrapper">
<a class="logo" href="../../index.html">
<img alt="Logo" src="../../_static/logo_horizontal.svg"/>
</a>
<a class="navigation-menu-button" href="javascript:void(0)" id="js-mobile-menu">Menu</a>
<nav>
<ul class="navigation-menu show" id="js-navigation-menu">
<li class="nav-link doc-head"><a href="https://github.com/holoviz/datashader/">Github</a></li>
<li class="nav-link doc-head"><a href="https://twitter.com/datashader/">Twitter</a></li>
<li class="nav-link doc-head"><a href="https://discourse.holoviz.org/">Discourse</a></li>
<li class="nav-link doc-head"><a href="https://holoviz.org">HoloViz</a></li>
<li class="nav-link">
<div style="display:inline-block;vertical-align: middle;">
<div class="search-bar">
<form action="../../search.html" method="get" role="search">
<input name="q" placeholder="Search" type="search"/>
<button type="submit">
<img alt="Search Icon" src="https://raw.githubusercontent.com/thoughtbot/refills/master/source/images/search-icon-black.png"/>
</button>
</form>
</div>
</div>
</li>
</ul>
</nav>
</div>
</header>
<div class="second-nav">
<nav>
<ul class="navigation-menu show">
<li class="nav-link doc-head"><a href="../../getting_started/index.html">Getting Started</a></li>
<li class="nav-link doc-head"><a href="../../user_guide/index.html">User Guide</a></li>
<li class="nav-link doc-head"><a href="../../topics/index.html">Topics</a></li>
<li class="nav-link doc-head"><a href="../../api.html">API</a></li>
<li class="nav-link doc-head"><a href="../../FAQ.html">FAQ</a></li>
<li class="nav-link doc-head"><a href="../../about.html">About</a></li>
</ul>
</nav>
</div>
<!-- MAIN BODY OF DOCS –––––––––––––––––– -->
<div class="docs section">
<div id="hacketyhackhack"> <!-- style="width:20%;margin-right: 100px;"> --> <!--style="display: none;"> style="display:none;"> -->
<div class="toc" style="width:15%; margin-right:20px;">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/index.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user_guide/index.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../topics/index.html">Topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../FAQ.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
</ul>
</div>
</div>
<div class="content"> <!-- style="max-width:80%;margin-left:auto;margin-right: auto;">-->
<h1>Source code for datashader.transfer_functions</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterator</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span> <span class="c1"># py2.7</span>
    <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Iterator</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">BytesIO</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numba</span> <span class="k">as</span> <span class="nn">nb</span>
<span class="kn">import</span> <span class="nn">toolz</span> <span class="k">as</span> <span class="nn">tz</span>
<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="kn">from</span> <span class="nn">PIL.Image</span> <span class="kn">import</span> <span class="n">fromarray</span>

<span class="kn">from</span> <span class="nn">datashader.colors</span> <span class="kn">import</span> <span class="n">rgb</span><span class="p">,</span> <span class="n">Sets1to3</span>
<span class="kn">from</span> <span class="nn">datashader.composite</span> <span class="kn">import</span> <span class="n">composite_op_lookup</span><span class="p">,</span> <span class="n">over</span><span class="p">,</span> <span class="n">validate_operator</span>
<span class="kn">from</span> <span class="nn">datashader.utils</span> <span class="kn">import</span> <span class="n">nansum_missing</span><span class="p">,</span> <span class="n">ngjit</span><span class="p">,</span> <span class="n">orient_array</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">cupy</span>
<span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
    <span class="n">cupy</span> <span class="o">=</span> <span class="kc">None</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'Image'</span><span class="p">,</span> <span class="s1">'stack'</span><span class="p">,</span> <span class="s1">'shade'</span><span class="p">,</span> <span class="s1">'set_background'</span><span class="p">,</span> <span class="s1">'spread'</span><span class="p">,</span> <span class="s1">'dynspread'</span><span class="p">]</span>


<div class="viewcode-block" id="Image"><a class="viewcode-back" href="../../api.html#datashader.transfer_functions.Image">[docs]</a><span class="k">class</span> <span class="nc">Image</span><span class="p">(</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mi">70</span>
    <span class="n">border</span><span class="o">=</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">to_pil</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">'lower'</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="n">cupy</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">cupy</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="k">if</span> <span class="n">origin</span> <span class="o">==</span> <span class="s1">'lower'</span> <span class="k">else</span> <span class="n">data</span>
        <span class="k">return</span> <span class="n">fromarray</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="s1">'RGBA'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_bytesio</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">'png'</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">'lower'</span><span class="p">):</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">to_pil</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="nb">format</span><span class="p">)</span>
        <span class="n">fp</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fp</span>

    <span class="k">def</span> <span class="nf">_repr_png_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Supports rich PNG display in a Jupyter notebook"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_pil</span><span class="p">()</span><span class="o">.</span><span class="n">_repr_png_</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Supports rich HTML display in a Jupyter notebook"""</span>
        <span class="c1"># imported here to avoid depending on these packages unless actually used</span>
        <span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">BytesIO</span>
        <span class="kn">from</span> <span class="nn">base64</span> <span class="kn">import</span> <span class="n">b64encode</span>

        <span class="n">b</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">to_pil</span><span class="p">()</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">'png'</span><span class="p">)</span>

        <span class="n">h</span> <span class="o">=</span> <span class="s2">"""&lt;img style="margin: auto; border:"""</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">border</span><span class="p">)</span> <span class="o">+</span> <span class="s2">"""px solid" """</span> <span class="o">+</span> \
            <span class="sd">"""src='data:image/png;base64,{0}'/&gt;"""</span><span class="o">.</span>\
                <span class="nb">format</span><span class="p">(</span><span class="n">b64encode</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">getvalue</span><span class="p">())</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">'utf-8'</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">h</span></div>



<span class="k">class</span> <span class="nc">Images</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A list of HTML-representable objects to display in a table.</span>
<span class="sd">    Primarily intended for Image objects, but could be anything</span>
<span class="sd">    that has _repr_html_.</span>
<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">images</span><span class="p">):</span>
        <span class="sd">"""Makes an HTML table from a list of HTML-representable arguments."""</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">images</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="s2">"_repr_html_"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">images</span> <span class="o">=</span> <span class="n">images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set the number of columns to use in the HTML table.</span>
<span class="sd">        Returns self for convenience.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span><span class="o">=</span><span class="n">n</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Supports rich display in a Jupyter notebook, using an HTML table"""</span>
        <span class="n">htmls</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">col</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">tr</span><span class="o">=</span><span class="s2">"""&lt;tr style="background-color:white"&gt;"""</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">images</span><span class="p">:</span>
            <span class="n">label</span><span class="o">=</span><span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="s2">"name"</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">""</span>

            <span class="n">htmls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"""&lt;td style="text-align: center"&gt;&lt;b&gt;"""</span> <span class="o">+</span> <span class="n">label</span> <span class="o">+</span>
                         <span class="sd">"""&lt;/b&gt;&lt;br&gt;&lt;br&gt;{0}&lt;/td&gt;"""</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">_repr_html_</span><span class="p">()))</span>
            <span class="n">col</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">col</span><span class="o">&gt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span><span class="p">:</span>
                <span class="n">col</span><span class="o">=</span><span class="mi">0</span>
                <span class="n">htmls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"&lt;/tr&gt;"</span><span class="o">+</span><span class="n">tr</span><span class="p">)</span>

        <span class="k">return</span> <span class="s2">"""&lt;table style="width:100%; text-align: center"&gt;&lt;tbody&gt;"""</span><span class="o">+</span> <span class="n">tr</span> <span class="o">+</span>\
               <span class="s2">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">htmls</span><span class="p">)</span> <span class="o">+</span> <span class="s2">"""&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;"""</span>



<div class="viewcode-block" id="stack"><a class="viewcode-back" href="../../api.html#datashader.transfer_functions.stack">[docs]</a><span class="k">def</span> <span class="nf">stack</span><span class="p">(</span><span class="o">*</span><span class="n">imgs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">"""Combine images together, overlaying later images onto earlier ones.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    imgs : iterable of Image</span>
<span class="sd">        The images to combine.</span>
<span class="sd">    how : str, optional</span>
<span class="sd">        The compositing operator to combine pixels. Default is `'over'`.</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">imgs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"No images passed in"</span><span class="p">)</span>
    <span class="n">shapes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">imgs</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Image</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Expected `Image`, got: `</span><span class="si">{0}</span><span class="s2">`"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">shapes</span><span class="p">:</span>
            <span class="n">shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">shapes</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">shape</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"The stacked images must have the same shape."</span><span class="p">)</span>

    <span class="n">name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'name'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">composite_op_lookup</span><span class="p">[</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'how'</span><span class="p">,</span> <span class="s1">'over'</span><span class="p">)]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">imgs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">imgs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">imgs</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="o">*</span><span class="n">imgs</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s1">'outer'</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">tz</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">tz</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">op</span><span class="p">),</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">data</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">imgs</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">Image</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">imgs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">imgs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">eq_hist</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">256</span><span class="o">*</span><span class="mi">256</span><span class="p">):</span>
    <span class="sd">"""Return a numpy array after histogram equalization.</span>

<span class="sd">    For use in `shade`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">    mask : ndarray, optional</span>
<span class="sd">       Boolean array of missing points. Where True, the output will be `NaN`.</span>
<span class="sd">    nbins : int, optional</span>
<span class="sd">        Number of bins to use. Note that this argument is ignored for integer</span>
<span class="sd">        arrays, which bin by the integer values directly.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function is adapted from the implementation in scikit-image [1]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] http://scikit-image.org/docs/stable/api/skimage.exposure.html#equalize-hist</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">cupy</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cupy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">from</span><span class="o">.</span><span class="n">_cuda_utils</span> <span class="kn">import</span> <span class="nn">interp</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"data must be an ndarray"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">interp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span>

    <span class="n">data2</span> <span class="o">=</span> <span class="n">data</span> <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">data2</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">data2</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">data2</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">'u'</span><span class="p">:</span>
             <span class="n">data2</span> <span class="o">=</span> <span class="n">data2</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">'i8'</span><span class="p">)</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">data2</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">bin_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hist</span><span class="p">))</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">hist</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">hist</span><span class="p">,</span> <span class="n">bin_centers</span> <span class="o">=</span> <span class="n">hist</span><span class="p">[</span><span class="n">idx</span><span class="p">:],</span> <span class="n">bin_centers</span><span class="p">[</span><span class="n">idx</span><span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hist</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">data2</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">nbins</span><span class="p">)</span>
        <span class="n">bin_centers</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">cdf</span> <span class="o">=</span> <span class="n">hist</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
    <span class="n">cdf</span> <span class="o">=</span> <span class="n">cdf</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">cdf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bin_centers</span><span class="p">,</span> <span class="n">cdf</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span> <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>


<span class="n">_interpolate_lookup</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'log'</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">d</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">d</span><span class="p">)),</span>
                       <span class="s1">'cbrt'</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">d</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mf">3.</span><span class="p">),</span>
                       <span class="s1">'linear'</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">d</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">d</span><span class="p">),</span>
                       <span class="s1">'eq_hist'</span><span class="p">:</span> <span class="n">eq_hist</span><span class="p">}</span>


<span class="k">def</span> <span class="nf">_normalize_interpolate_how</span><span class="p">(</span><span class="n">how</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">how</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">how</span>
    <span class="k">elif</span> <span class="n">how</span> <span class="ow">in</span> <span class="n">_interpolate_lookup</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_interpolate_lookup</span><span class="p">[</span><span class="n">how</span><span class="p">]</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Unknown interpolation method: </span><span class="si">{0}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">how</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_interpolate</span><span class="p">(</span><span class="n">agg</span><span class="p">,</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">how</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">min_alpha</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">cupy</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">agg</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">cupy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">._cuda_utils</span> <span class="kn">import</span> <span class="n">masked_clip_2d</span><span class="p">,</span> <span class="n">interp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">._cpu_utils</span> <span class="kn">import</span> <span class="n">masked_clip_2d</span>
        <span class="n">interp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span>

    <span class="k">if</span> <span class="n">agg</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"agg must be 2D"</span><span class="p">)</span>
    <span class="n">interpolater</span> <span class="o">=</span> <span class="n">_normalize_interpolate_how</span><span class="p">(</span><span class="n">how</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">orient_array</span><span class="p">(</span><span class="n">agg</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Compute mask</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">'u'</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">data</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="c1"># Handle case where everything is masked out</span>
    <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">Image</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                              <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span>
                     <span class="n">dims</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="c1"># Handle offset / clip</span>
    <span class="k">if</span> <span class="n">span</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">masked_clip_2d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="o">*</span><span class="n">span</span><span class="p">)</span>

    <span class="c1"># If log/cbrt, could case to float64 right away</span>
    <span class="c1"># If linear, can keep current type</span>
    <span class="n">data</span> <span class="o">-=</span> <span class="n">offset</span>

    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s2">"ignore"</span><span class="p">,</span> <span class="n">divide</span><span class="o">=</span><span class="s2">"ignore"</span><span class="p">):</span>
        <span class="c1"># Transform data (log, eq_hist, etc.)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">interpolater</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>

        <span class="c1"># Transform span</span>
        <span class="k">if</span> <span class="n">span</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">masked_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">span</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">masked_data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">masked_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">'eq_hist'</span><span class="p">:</span>
                <span class="c1"># For eq_hist to work with span, we'll need to compute the histogram</span>
                <span class="c1"># only on the specified span's range.</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"span is not (yet) valid to use with eq_hist"</span><span class="p">)</span>

            <span class="n">span</span> <span class="o">=</span> <span class="n">interpolater</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">span</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">span</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">):</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">rspan</span><span class="p">,</span> <span class="n">gspan</span><span class="p">,</span> <span class="n">bspan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="n">rgb</span><span class="p">,</span> <span class="n">cmap</span><span class="p">))))</span>
        <span class="n">span</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">span</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">span</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">cmap</span><span class="p">))</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">rspan</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">gspan</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">bspan</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">rgba</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">])</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">rgb</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">aspan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">min_alpha</span><span class="p">,</span> <span class="n">alpha</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">span</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">span</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">span</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">aspan</span><span class="p">))</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">color</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">color</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">color</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">aspan</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">rgba</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">cmap</span><span class="p">):</span>
        <span class="c1"># Assume callable is matplotlib colormap</span>
        <span class="n">scaled_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">span</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">span</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">span</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">cupy</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scaled_data</span><span class="p">,</span> <span class="n">cupy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="c1"># Convert cupy array to numpy before passing to matplotlib colormap</span>
            <span class="n">scaled_data</span> <span class="o">=</span> <span class="n">cupy</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">scaled_data</span><span class="p">)</span>

        <span class="n">rgba</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span><span class="n">scaled_data</span><span class="p">,</span> <span class="nb">bytes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">rgba</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">scaled_data</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Expected `cmap` of `matplotlib.colors.Colormap`, "</span>
                        <span class="s2">"`list`, `str`, or `tuple`; got: '</span><span class="si">{0}</span><span class="s2">'"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">cmap</span><span class="p">)))</span>

    <span class="n">img</span> <span class="o">=</span> <span class="n">rgba</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cupy</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cupy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="c1"># Convert cupy array to numpy for final image</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">cupy</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Image</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_colorize</span><span class="p">(</span><span class="n">agg</span><span class="p">,</span> <span class="n">color_key</span><span class="p">,</span> <span class="n">how</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">min_alpha</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">color_baseline</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">cupy</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">agg</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">cupy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">._cuda_utils</span> <span class="kn">import</span> <span class="n">interp</span><span class="p">,</span> <span class="n">masked_clip_2d</span> 
        <span class="n">array</span> <span class="o">=</span> <span class="n">cupy</span><span class="o">.</span><span class="n">array</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">._cpu_utils</span> <span class="kn">import</span> <span class="n">masked_clip_2d</span>
        <span class="n">interp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">agg</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"agg must be 3D"</span><span class="p">)</span>
    
    <span class="n">cats</span> <span class="o">=</span> <span class="n">agg</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">cats</span><span class="p">):</span> <span class="c1"># No categories and therefore no data; return an empty image</span>
        <span class="k">return</span> <span class="n">Image</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">agg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">),</span> <span class="n">dims</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                     <span class="n">coords</span><span class="o">=</span><span class="n">OrderedDict</span><span class="p">([</span>
                         <span class="p">(</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">agg</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span>
                         <span class="p">(</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">agg</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="p">]),</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">color_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Color key must be provided, with at least as many "</span> <span class="o">+</span>
                         <span class="s2">"colors as there are categorical fields"</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">color_key</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">color_key</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">cats</span><span class="p">,</span> <span class="n">color_key</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">color_key</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">cats</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Insufficient colors provided (</span><span class="si">{}</span><span class="s2">) for the categorical fields available (</span><span class="si">{}</span><span class="s2">)"</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">color_key</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">cats</span><span class="p">)))</span>

    <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">rgb</span><span class="p">(</span><span class="n">color_key</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cats</span><span class="p">]</span>
    <span class="n">rs</span><span class="p">,</span> <span class="n">gs</span><span class="p">,</span> <span class="n">bs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">colors</span><span class="p">))</span>
    <span class="c1"># Reorient array (transposing the category dimension first)</span>
    <span class="n">agg_t</span> <span class="o">=</span> <span class="n">agg</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],)</span><span class="o">+</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">[:</span><span class="mi">2</span><span class="p">]))</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">orient_array</span><span class="p">(</span><span class="n">agg_t</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
    <span class="n">color_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># subtract color_baseline if needed</span>
    <span class="n">baseline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">color_data</span><span class="p">)</span> <span class="k">if</span> <span class="n">color_baseline</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">color_baseline</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">baseline</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">color_data</span> <span class="o">-=</span> <span class="n">baseline</span>
        <span class="k">elif</span> <span class="n">baseline</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">color_data</span> <span class="o">+=</span> <span class="o">-</span><span class="n">baseline</span>
        <span class="k">if</span> <span class="n">color_data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="s1">'u'</span> <span class="ow">and</span> <span class="n">color_baseline</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">color_data</span><span class="p">[</span><span class="n">color_data</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>

    <span class="n">color_total</span> <span class="o">=</span> <span class="n">nansum_missing</span><span class="p">(</span><span class="n">color_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># dot does not handle nans, so replace with zeros</span>
    <span class="n">color_data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># zero-count pixels will be 0/0, but it's safe to ignore that when dividing</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">color_data</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span><span class="o">/</span><span class="n">color_total</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="n">color_data</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">gs</span><span class="p">)</span><span class="o">/</span><span class="n">color_total</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">color_data</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span><span class="o">/</span><span class="n">color_total</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

    <span class="c1"># special case -- to give an appropriate color when min_alpha != 0 and data=0,</span>
    <span class="c1"># take avg color of all non-nan categories</span>
    <span class="n">color_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">cmask_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">color_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">):</span>
        <span class="n">r2</span> <span class="o">=</span> <span class="p">(</span><span class="n">color_mask</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span><span class="o">/</span><span class="n">cmask_sum</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">g2</span> <span class="o">=</span> <span class="p">(</span><span class="n">color_mask</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">gs</span><span class="p">)</span><span class="o">/</span><span class="n">cmask_sum</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="p">(</span><span class="n">color_mask</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span><span class="o">/</span><span class="n">cmask_sum</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

    <span class="n">missing_colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">color_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">missing_colors</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">missing_colors</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">missing_colors</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        
    <span class="n">total</span> <span class="o">=</span> <span class="n">nansum_missing</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>
    <span class="c1"># if span is provided, use it, otherwise produce a span based off the</span>
    <span class="c1"># min/max of the data</span>
    <span class="k">if</span> <span class="n">span</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">total</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">'u'</span> <span class="ow">and</span> <span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">|</span> <span class="p">(</span><span class="n">total</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="c1"># If at least one element is not masked, use the minimum as the offset</span>
            <span class="c1"># otherwise the offset remains at zero</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">total</span><span class="p">[</span><span class="n">total</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">a_scaled</span> <span class="o">=</span> <span class="n">_normalize_interpolate_how</span><span class="p">(</span><span class="n">how</span><span class="p">)(</span><span class="n">total</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
        <span class="n">norm_span</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">a_scaled</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">a_scaled</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">'eq_hist'</span><span class="p">:</span>
            <span class="c1"># For eq_hist to work with span, we'll need to compute the histogram</span>
            <span class="c1"># only on the specified span's range.</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"span is not (yet) valid to use with eq_hist"</span><span class="p">)</span>
        <span class="c1"># even in fixed-span mode cells with 0 should remain fully transparent</span>
        <span class="c1"># i.e. a 0 will be fully transparent, but any non-zero number will</span>
        <span class="c1"># be clipped to the span range and have min-alpha applied</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">total</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">'u'</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">total</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">|</span> <span class="p">(</span><span class="n">total</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">masked_clip_2d</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="o">*</span><span class="n">span</span><span class="p">)</span>
        <span class="n">a_scaled</span> <span class="o">=</span> <span class="n">_normalize_interpolate_how</span><span class="p">(</span><span class="n">how</span><span class="p">)(</span><span class="n">total</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
        <span class="n">norm_span</span> <span class="o">=</span> <span class="n">_normalize_interpolate_how</span><span class="p">(</span><span class="n">how</span><span class="p">)([</span><span class="mi">0</span><span class="p">,</span> <span class="n">span</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">span</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Interpolate the alpha values</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">a_scaled</span><span class="p">,</span> <span class="n">array</span><span class="p">(</span><span class="n">norm_span</span><span class="p">),</span> <span class="n">array</span><span class="p">([</span><span class="n">min_alpha</span><span class="p">,</span> <span class="n">alpha</span><span class="p">]),</span>
               <span class="n">left</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

    <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">])</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cupy</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">cupy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="c1"># Convert cupy array to numpy for final image</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">cupy</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Image</span><span class="p">(</span><span class="n">values</span><span class="p">,</span>
                 <span class="n">dims</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                 <span class="n">coords</span><span class="o">=</span><span class="n">OrderedDict</span><span class="p">([</span>
                     <span class="p">(</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">agg</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span>
                     <span class="p">(</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">agg</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span>
                 <span class="p">]),</span>
                 <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<div class="viewcode-block" id="shade"><a class="viewcode-back" href="../../api.html#datashader.transfer_functions.shade">[docs]</a><span class="k">def</span> <span class="nf">shade</span><span class="p">(</span><span class="n">agg</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="p">[</span><span class="s2">"lightblue"</span><span class="p">,</span> <span class="s2">"darkblue"</span><span class="p">],</span> <span class="n">color_key</span><span class="o">=</span><span class="n">Sets1to3</span><span class="p">,</span>
          <span class="n">how</span><span class="o">=</span><span class="s1">'eq_hist'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">255</span><span class="p">,</span> <span class="n">min_alpha</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">span</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">color_baseline</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">"""Convert a DataArray to an image by choosing an RGBA pixel color for each value.</span>

<span class="sd">    Requires a DataArray with a single data dimension, here called the</span>
<span class="sd">    "value", indexed using either 2D or 3D coordinates.</span>

<span class="sd">    For a DataArray with 2D coordinates, the RGB channels are computed</span>
<span class="sd">    from the values by interpolated lookup into the given colormap</span>
<span class="sd">    ``cmap``.  The A channel is then set to the given fixed ``alpha``</span>
<span class="sd">    value for all non-zero values, and to zero for all zero values.</span>

<span class="sd">    DataArrays with 3D coordinates are expected to contain values</span>
<span class="sd">    distributed over different categories that are indexed by the</span>
<span class="sd">    additional coordinate.  Such an array would reduce to the</span>
<span class="sd">    2D-coordinate case if collapsed across the categories (e.g. if one</span>
<span class="sd">    did ``aggc.sum(dim='cat')`` for a categorical dimension ``cat``).</span>
<span class="sd">    The RGB channels for the uncollapsed, 3D case are computed by</span>
<span class="sd">    averaging the colors in the provided ``color_key`` (with one color</span>
<span class="sd">    per category), weighted by the array's value for that category.</span>
<span class="sd">    The A channel is then computed from the array's total value</span>
<span class="sd">    collapsed across all categories at that location, ranging from the</span>
<span class="sd">    specified ``min_alpha`` to the maximum alpha value (255).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    agg : DataArray</span>
<span class="sd">    cmap : list of colors or matplotlib.colors.Colormap, optional</span>
<span class="sd">        The colormap to use for 2D agg arrays. Can be either a list of</span>
<span class="sd">        colors (specified either by name, RGBA hexcode, or as a tuple</span>
<span class="sd">        of ``(red, green, blue)`` values.), or a matplotlib colormap</span>
<span class="sd">        object.  Default is ``["lightblue", "darkblue"]``.</span>
<span class="sd">    color_key : dict or iterable</span>
<span class="sd">        The colors to use for a 3D (categorical) agg array.  Can be</span>
<span class="sd">        either a ``dict`` mapping from field name to colors, or an</span>
<span class="sd">        iterable of colors in the same order as the record fields,</span>
<span class="sd">        and including at least that many distinct colors.</span>
<span class="sd">    how : str or callable, optional</span>
<span class="sd">        The interpolation method to use, for the ``cmap`` of a 2D</span>
<span class="sd">        DataArray or the alpha channel of a 3D DataArray. Valid</span>
<span class="sd">        strings are 'eq_hist' [default], 'cbrt' (cube root), 'log'</span>
<span class="sd">        (logarithmic), and 'linear'. Callables take 2 arguments - a</span>
<span class="sd">        2-dimensional array of magnitudes at each pixel, and a boolean</span>
<span class="sd">        mask array indicating missingness. They should return a numeric</span>
<span class="sd">        array of the same shape, with ``NaN`` values where the mask was</span>
<span class="sd">        True.</span>
<span class="sd">    alpha : int, optional</span>
<span class="sd">        Value between 0 - 255 representing the alpha value to use for</span>
<span class="sd">        colormapped pixels that contain data (i.e. non-NaN values).</span>
<span class="sd">        Also used as the maximum alpha value when alpha is indicating</span>
<span class="sd">        data value, such as for single colors or categorical plots.</span>
<span class="sd">        Regardless of this value, ``NaN`` values are set to be fully</span>
<span class="sd">        transparent when doing colormapping.</span>
<span class="sd">    min_alpha : float, optional</span>
<span class="sd">        The minimum alpha value to use for non-empty pixels when </span>
<span class="sd">        alpha is indicating data value, in [0, 255].  Use a higher value</span>
<span class="sd">        to avoid undersaturation, i.e. poorly visible low-value datapoints,</span>
<span class="sd">        at the expense of the overall dynamic range.</span>
<span class="sd">    span : list of min-max range, optional</span>
<span class="sd">        Min and max data values to use for colormap/alpha interpolation, when</span>
<span class="sd">        wishing to override autoranging.</span>
<span class="sd">    name : string name, optional</span>
<span class="sd">        Optional string name to give to the Image object to return,</span>
<span class="sd">        to label results for display.</span>
<span class="sd">    color_baseline : float or None</span>
<span class="sd">        Baseline for calculating how categorical data mixes to</span>
<span class="sd">        determine the color of a pixel. The color for each category is</span>
<span class="sd">        weighted by how far that category's value is above this</span>
<span class="sd">        baseline value, out of the total sum across all categories'</span>
<span class="sd">        values. A value of zero is appropriate for counts and for</span>
<span class="sd">        other physical quantities for which zero is a meaningful</span>
<span class="sd">        reference; each category then contributes to the final color</span>
<span class="sd">        in proportion to how much each category contributes to the</span>
<span class="sd">        final sum.  However, if values can be negative or if they are</span>
<span class="sd">        on an interval scale where values e.g. twice as far from zero</span>
<span class="sd">        are not twice as high (such as temperature in Farenheit), then</span>
<span class="sd">        you will need to provide a suitable baseline value for use in</span>
<span class="sd">        calculating color mixing.  A value of None (the default) means</span>
<span class="sd">        to take the minimum across the entire aggregate array, which</span>
<span class="sd">        is safe but may not weight the colors as you expect; any</span>
<span class="sd">        categories with values near this baseline will contribute</span>
<span class="sd">        almost nothing to the final color. As a special case, if the</span>
<span class="sd">        only data present in a pixel is at the baseline level, the</span>
<span class="sd">        color will be an evenly weighted average of all such</span>
<span class="sd">        categories with data (to avoid the color being undefined in</span>
<span class="sd">        this case).</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">agg</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"agg must be instance of DataArray"</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">agg</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">name</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">min_alpha</span> <span class="o">&lt;=</span> <span class="mi">255</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">alpha</span> <span class="o">&lt;=</span> <span class="mi">255</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"min_alpha (</span><span class="si">{}</span><span class="s2">) and alpha (</span><span class="si">{}</span><span class="s2">) must be between 0 and 255"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">min_alpha</span><span class="p">,</span><span class="n">alpha</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">agg</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_interpolate</span><span class="p">(</span><span class="n">agg</span><span class="p">,</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">how</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">min_alpha</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">agg</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_colorize</span><span class="p">(</span><span class="n">agg</span><span class="p">,</span> <span class="n">color_key</span><span class="p">,</span> <span class="n">how</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">min_alpha</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">color_baseline</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"agg must use 2D or 3D coordinates"</span><span class="p">)</span></div>


<div class="viewcode-block" id="set_background"><a class="viewcode-back" href="../../api.html#datashader.transfer_functions.set_background">[docs]</a><span class="k">def</span> <span class="nf">set_background</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">"""Return a new image, with the background set to `color`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------------</span>
<span class="sd">    img : Image</span>
<span class="sd">    color : color name or tuple, optional</span>
<span class="sd">        The background color. Can be specified either by name, hexcode, or as a</span>
<span class="sd">        tuple of ``(red, green, blue)`` values.</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">Image</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Expected `Image`, got: `</span><span class="si">{0}</span><span class="s2">`"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">img</span><span class="p">)))</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">name</span>
    <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">img</span>
    <span class="n">background</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">rgb</span><span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">255</span><span class="p">,))</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s1">'uint32'</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">over</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">background</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Image</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="spread"><a class="viewcode-back" href="../../api.html#datashader.transfer_functions.spread">[docs]</a><span class="k">def</span> <span class="nf">spread</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">px</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="s1">'circle'</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">"""Spread pixels in an image.</span>

<span class="sd">    Spreading expands each pixel a certain number of pixels on all sides</span>
<span class="sd">    according to a given shape, merging pixels using a specified compositing</span>
<span class="sd">    operator. This can be useful to make sparse plots more visible.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    img : Image or other DataArray</span>
<span class="sd">    px : int, optional</span>
<span class="sd">        Number of pixels to spread on all sides</span>
<span class="sd">    shape : str, optional</span>
<span class="sd">        The shape to spread by. Options are 'circle' [default] or 'square'.</span>
<span class="sd">    how : str, optional</span>
<span class="sd">        The name of the compositing operator to use when combining</span>
<span class="sd">        pixels. Default of None uses 'over' operator for Image objects</span>
<span class="sd">        and 'add' operator otherwise.</span>
<span class="sd">    mask : ndarray, shape (M, M), optional</span>
<span class="sd">        The mask to spread over. If provided, this mask is used instead of</span>
<span class="sd">        generating one based on `px` and `shape`. Must be a square array</span>
<span class="sd">        with odd dimensions. Pixels are spread from the center of the mask to</span>
<span class="sd">        locations where the mask is True.</span>
<span class="sd">    name : string name, optional</span>
<span class="sd">        Optional string name to give to the Image object to return,</span>
<span class="sd">        to label results for display.</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Expected `xr.DataArray`, got: `</span><span class="si">{0}</span><span class="s2">`"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">img</span><span class="p">)))</span>
    <span class="n">is_image</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">Image</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">name</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">px</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"``px`` must be an integer &gt;= 0"</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">px</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">img</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">_mask_lookup</span><span class="p">[</span><span class="n">shape</span><span class="p">](</span><span class="n">px</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">mask</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span>
              <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"mask must be a square 2 dimensional ndarray with "</span>
                         <span class="s2">"odd dimensions."</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">'bool'</span> <span class="k">else</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">'bool'</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">how</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">how</span> <span class="o">=</span> <span class="s1">'over'</span> <span class="k">if</span> <span class="n">is_image</span> <span class="k">else</span> <span class="s1">'add'</span>

    <span class="n">w</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">extra</span> <span class="o">=</span> <span class="n">w</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">padded_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">extra</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">extra</span><span class="p">)</span>
    <span class="n">float_type</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span>
    <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">if</span> <span class="n">float_type</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">is_image</span><span class="p">:</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">_build_spread_kernel</span><span class="p">(</span><span class="n">how</span><span class="p">,</span> <span class="n">is_image</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">float_type</span><span class="p">:</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">_build_float_kernel</span><span class="p">(</span><span class="n">how</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">_build_int_kernel</span><span class="p">(</span><span class="n">how</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply_kernel</span><span class="p">(</span><span class="n">layer</span><span class="p">):</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">padded_shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">layer</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">kernel</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">buf</span><span class="p">[</span><span class="n">extra</span><span class="p">:</span><span class="o">-</span><span class="n">extra</span><span class="p">,</span> <span class="n">extra</span><span class="p">:</span><span class="o">-</span><span class="n">extra</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">apply_kernel</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">apply_kernel</span><span class="p">(</span><span class="n">img</span><span class="p">[:,:,</span><span class="n">category</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])])</span>

    <span class="k">return</span> <span class="n">img</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>


<span class="nd">@tz</span><span class="o">.</span><span class="n">memoize</span>
<span class="k">def</span> <span class="nf">_build_int_kernel</span><span class="p">(</span><span class="n">how</span><span class="p">,</span> <span class="n">mask_size</span><span class="p">,</span> <span class="n">ignore_zeros</span><span class="p">):</span>
    <span class="sd">"""Build a spreading kernel for a given composite operator"""</span>
    <span class="n">validate_operator</span><span class="p">(</span><span class="n">how</span><span class="p">,</span> <span class="n">is_image</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">composite_op_lookup</span><span class="p">[</span><span class="n">how</span> <span class="o">+</span> <span class="s2">"_arr"</span><span class="p">]</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">stencilled</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">el</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mask_size</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mask_size</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">ignore_zeros</span> <span class="ow">and</span> <span class="n">el</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                                <span class="n">result</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span>
                            <span class="k">elif</span> <span class="n">ignore_zeros</span> <span class="ow">and</span> <span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                                <span class="n">result</span> <span class="o">=</span> <span class="n">el</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">x</span><span class="p">])</span>
                            <span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">stencilled</span>


<span class="nd">@tz</span><span class="o">.</span><span class="n">memoize</span>
<span class="k">def</span> <span class="nf">_build_float_kernel</span><span class="p">(</span><span class="n">how</span><span class="p">,</span> <span class="n">mask_size</span><span class="p">):</span>
    <span class="sd">"""Build a spreading kernel for a given composite operator"""</span>
    <span class="n">validate_operator</span><span class="p">(</span><span class="n">how</span><span class="p">,</span> <span class="n">is_image</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">composite_op_lookup</span><span class="p">[</span><span class="n">how</span> <span class="o">+</span> <span class="s2">"_arr"</span><span class="p">]</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">stencilled</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">el</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mask_size</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mask_size</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">el</span><span class="p">):</span>
                                <span class="n">result</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span>
                            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">x</span><span class="p">]):</span>
                                <span class="n">result</span> <span class="o">=</span> <span class="n">el</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">x</span><span class="p">])</span>
                            <span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">stencilled</span>


<span class="nd">@tz</span><span class="o">.</span><span class="n">memoize</span>
<span class="k">def</span> <span class="nf">_build_spread_kernel</span><span class="p">(</span><span class="n">how</span><span class="p">,</span> <span class="n">is_image</span><span class="p">):</span>
    <span class="sd">"""Build a spreading kernel for a given composite operator"""</span>
    <span class="n">validate_operator</span><span class="p">(</span><span class="n">how</span><span class="p">,</span> <span class="n">is_image</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">composite_op_lookup</span><span class="p">[</span><span class="n">how</span> <span class="o">+</span> <span class="p">(</span><span class="s2">""</span> <span class="k">if</span> <span class="n">is_image</span> <span class="k">else</span> <span class="s2">"_arr"</span><span class="p">)]</span>

    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">kernel</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">el</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
                <span class="c1"># Skip if data is transparent</span>
                <span class="n">process_image</span> <span class="o">=</span> <span class="n">is_image</span> <span class="ow">and</span> <span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">255</span><span class="p">)</span> <span class="c1"># Transparent pixel</span>
                <span class="n">process_array</span> <span class="o">=</span> <span class="p">(</span><span class="ow">not</span> <span class="n">is_image</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">el</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">process_image</span> <span class="ow">or</span> <span class="n">process_array</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
                            <span class="c1"># Skip if mask is False at this value</span>
                            <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]:</span>
                                <span class="k">if</span> <span class="n">el</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                                    <span class="n">result</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span>
                                <span class="k">if</span> <span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                                    <span class="n">result</span> <span class="o">=</span> <span class="n">el</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">x</span><span class="p">])</span>
                                <span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">kernel</span>


<span class="k">def</span> <span class="nf">_square_mask</span><span class="p">(</span><span class="n">px</span><span class="p">):</span>
    <span class="sd">"""Produce a square mask with sides of length ``2 * px + 1``"""</span>
    <span class="n">px</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">px</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">px</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'bool'</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_circle_mask</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
    <span class="sd">"""Produce a circular mask with a diameter of ``2 * r + 1``"""</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'i4'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>


<span class="n">_mask_lookup</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'square'</span><span class="p">:</span> <span class="n">_square_mask</span><span class="p">,</span>
                <span class="s1">'circle'</span><span class="p">:</span> <span class="n">_circle_mask</span><span class="p">}</span>


<div class="viewcode-block" id="dynspread"><a class="viewcode-back" href="../../api.html#datashader.transfer_functions.dynspread">[docs]</a><span class="k">def</span> <span class="nf">dynspread</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">max_px</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="s1">'circle'</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">"""Spread pixels in an image dynamically based on the image density.</span>

<span class="sd">    Spreading expands each pixel a certain number of pixels on all sides</span>
<span class="sd">    according to a given shape, merging pixels using a specified compositing</span>
<span class="sd">    operator. This can be useful to make sparse plots more visible. Dynamic</span>
<span class="sd">    spreading determines how many pixels to spread based on a density</span>
<span class="sd">    heuristic.  Spreading starts at 1 pixel, and stops when the fraction</span>
<span class="sd">    of adjacent non-empty pixels reaches the specified threshold, or</span>
<span class="sd">    the max_px is reached, whichever comes first.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    img : Image</span>
<span class="sd">    threshold : float, optional</span>
<span class="sd">        A tuning parameter in [0, 1], with higher values giving more</span>
<span class="sd">        spreading.</span>
<span class="sd">    max_px : int, optional</span>
<span class="sd">        Maximum number of pixels to spread on all sides.</span>
<span class="sd">    shape : str, optional</span>
<span class="sd">        The shape to spread by. Options are 'circle' [default] or 'square'.</span>
<span class="sd">    how : str, optional</span>
<span class="sd">        The name of the compositing operator to use when combining</span>
<span class="sd">        pixels. Default of None uses 'over' operator for Image objects</span>
<span class="sd">        and 'add' operator otherwise.</span>
<span class="sd">    """</span>
    <span class="n">is_image</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">Image</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">threshold</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"threshold must be in [0, 1]"</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_px</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">max_px</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"max_px must be &gt;= 0"</span><span class="p">)</span>
    <span class="c1"># Simple linear search. Not super efficient, but max_px is usually small.</span>
    <span class="n">float_type</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span>
    <span class="n">px_</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">px</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_px</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">px_</span><span class="o">=</span><span class="n">px</span>
        <span class="k">if</span> <span class="n">is_image</span><span class="p">:</span>
            <span class="n">density</span> <span class="o">=</span> <span class="n">_rgb_density</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">px</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">density</span> <span class="o">=</span> <span class="n">_array_density</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">float_type</span><span class="p">,</span> <span class="n">px</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">img</span><span class="p">))</span> <span class="k">if</span> <span class="n">float_type</span> <span class="k">else</span> <span class="p">(</span><span class="n">img</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">flat_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">masked</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'uint32'</span><span class="p">)</span>
            <span class="n">density</span> <span class="o">=</span> <span class="n">_array_density</span><span class="p">(</span><span class="n">flat_mask</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">px</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">density</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
            <span class="n">px_</span><span class="o">=</span><span class="n">px_</span><span class="o">-</span><span class="mi">1</span>
            <span class="k">break</span>
        
    <span class="k">if</span> <span class="n">px_</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spread</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">px_</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">img</span></div>


<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_array_density</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">float_type</span><span class="p">,</span> <span class="n">px</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">"""Compute a density heuristic of an array.</span>

<span class="sd">    The density is a number in [0, 1], and indicates the normalized mean number</span>
<span class="sd">    of non-empty pixels that have neighbors in the given px radius.</span>
<span class="sd">    """</span>
    <span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">cnt</span> <span class="o">=</span> <span class="n">has_neighbors</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
            <span class="n">el</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">float_type</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">el</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">float_type</span> <span class="ow">and</span> <span class="n">el</span><span class="o">!=</span><span class="mi">0</span><span class="p">):</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">neighbors</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>     <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="n">px</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">px</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">M</span><span class="p">)):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">px</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">px</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="p">((</span><span class="n">float_type</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span> <span class="ow">or</span>
                            <span class="p">(</span><span class="ow">not</span> <span class="n">float_type</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)):</span>
                            <span class="n">neighbors</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">neighbors</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># (excludes self)</span>
                    <span class="n">has_neighbors</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">has_neighbors</span><span class="o">/</span><span class="n">cnt</span> <span class="k">if</span> <span class="n">cnt</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>


<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_rgb_density</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">px</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">"""Compute a density heuristic of an image.</span>

<span class="sd">    The density is a number in [0, 1], and indicates the normalized mean number</span>
<span class="sd">    of non-empty pixels that have neighbors in the given px radius.</span>
<span class="sd">    """</span>
    <span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">cnt</span> <span class="o">=</span> <span class="n">has_neighbors</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">255</span><span class="p">:</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">neighbors</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>     <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="n">px</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">px</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">M</span><span class="p">)):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">px</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">px</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">255</span><span class="p">:</span>
                            <span class="n">neighbors</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">neighbors</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># (excludes self)</span>
                    <span class="n">has_neighbors</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">has_neighbors</span><span class="o">/</span><span class="n">cnt</span> <span class="k">if</span> <span class="n">cnt</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
</pre></div>
</div>
</div>
<!-- END MAIN BODY OF DOCS ––––––––––––– -->
<footer class="footer">
<div class="footer-links">
<ul>
<li><span class="footer-title">Links</span></li>
<li><a href="../../getting_started/index.html">Getting Started</a></li>
<li><a href="../../user_guide/index.html">User Guide</a></li>
<li><a href="../../topics/index.html">Topics</a></li>
<li><a href="../../api.html">API</a></li>
<li><a href="../../FAQ.html">FAQ</a></li>
<li><a href="../../about.html">About</a></li>
</ul>
<ul>
<li><span class="footer-title">Join Us</span></li>
<li><a href="https://github.com/holoviz/datashader/">Github</a></li>
<li><a href="https://twitter.com/datashader/">Twitter</a></li>
<li><a href="https://discourse.holoviz.org/">Discourse</a></li>
<li><a href="https://holoviz.org">HoloViz</a></li>
</ul>
<ul class="copyright">
<li>2016-2021, Anaconda, Inc.</li>
</ul>
</div>
</footer>
<!-- Google Analytics -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-154795830-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-154795830-1', { 'anonymize_ip': true });
</script>
<!-- MathJax Config -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>
<!-- End Document
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
</body>
</html>